Binary Search:(sorted array)
1. Search for target that exists. (index)

2. Search for smallest item that's bigger than target. (value, index)



3. Search for largest item that's smaller than target. (value, index)
This has a bit difference from subproblem 2.
private int search(int[] nums, int target, int start, int end){
    if(start == end){
        if (nums[start] < target){
            return start;
        }
        else{
            return start - 1;
        }
    }
    if(nums[start] >= target){
        return start - 1;
    }
    if(nums[end] < target){
        return end;
    }
    while(start != end){
        int mid = start + (end - start) / 2;
        //
        if((start - end) % 2 != 0){
                mid = mid + 1;
            }
        // This block is crucial because in binary search, the "mid" calculation has to go to a direction in order to avoid ties. 
        // For example in a array of [0,2], and we want to find elements less than 1.
        // if not for the block above, start would be 0 and end 1, mid would be 0, equal to start and it's an infinite loop.
        if(nums[mid] >= target){
            end = mid - 1;
        }
        else{
            start = mid;
        }
    }
    return start;
}